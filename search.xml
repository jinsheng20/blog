<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DLT（Diagnostic Log and Trace）简单应用]]></title>
    <url>%2F2019%2F07%2F26%2Fdlt-log%2F</url>
    <content type="text"><![CDATA[一、获取dlt-daemon源码 git clone https://github.com/GENIVI/dlt-daemon.git cd dlt-daemon mkdir build cd build cmake .. make sudo make install sudo ldconfigdlt-daemon 编译安装就完成了libdlt.so 位于 /usr/local/libdlt等头文件位置 /usr/local/include/dlt 二、启动dlt-daemon（守护进程）首先复制dlt.conf文件 cd dlt-daemon/src/daemon/ sudo cp dlt.conf /etc/ 可以通过sudo gedit /etc/dlt.conf 更改配置 DLT守护进程是从不同的应用程序中收集日志和跟踪信息的中心位置，这些日志和跟踪信息可以临时存储或永久存储，并传输到DLT客户机应用程序 三、输出日志程序编写可以参考 example 中例子 四、接收日志程序 通过安装 dlt-daemon会自动编译安装这个程序，也可以自己找到同名文件进行编译定制。 dlt-receive -f filter.txt -o ./log.dlt -a localhost dlt-receive -o ./log.dlt -a localhost 五、dlt-viewer 查看日志文件工具现装依赖包 sudo apt-get install libqt5serialport5-dev libqt5serialport5 git clone https://github.com/GENIVI/dlt-viewer.git mkdir build cd build cmake .. make 注意app context默认四字节 id默认一字节更加autosar 协议 所以最大255 输出日志程序， 和守护进程都有缓存机制。 The library path and include path must be set in the build environment prior to building a program using the shared dlt library. you may not call DLT_REGISTER_APP before fork() If your application uses fork(), you may not call DLT_REGISTER_APP before fork(). And fork() should never be called after DLT_REGISTER_APP. This is because of state information and inter process communication channel to daemon would be copied to new process, but threads would be not. # include &lt; dlt / dlt.h &gt; 首先要做的是包含DLT的标准头文件 DLT_DECLARE_CONTEXT (mycontext); 接下来是为应用程序的每个使用上下文创建实例。在使用任何上下文之前，这必须在源代码之外完成。 DLT_IMPORT_CONTEXT (mycontext); 如果在另一个软件模块中第二次使用上下文，则必须调用以下宏来访问上下文。 DLT_REGISTER_APP(“LOG”、“Test Application for Logging”); 在应用程序初始化的下一步中，应用程序必须在DLT守护进程中注册。应用程序的标识符(这里是“LOG”)最多有四个字符。 DLT_REGISTER_CONTEXT(mycontext，&quot;TEST&quot;，&quot; TEST Context for Logging&quot;); 然后必须在DLT守护进程中注册每个上下文。必须调用这个宏，以便DLT守护进程和客户机能够设置应用程序中上下文的日志级别。上下文的标识符(这里是“TEST”)最多有四个字符。此上下文使用默认日志级别和默认跟踪状态。 DLT_REGISTER_CONTEXT(mycontext，&quot;TEST&quot;，&quot; TEST Context for Logging&quot;，DLT_LOG_VERBOSE,DLT_TRACE_STATUS_ON); 作为替代，可以在期间提供特定的日志级别和跟踪状态 上下文的注册。现在在详细模式和非详细模式之间选择: DLT_LOG(mycontext ,DLT_LOG_WARN, DLT_INT(num),DLT_STRING(text)); 对于详细模式(默认):注册之后，可以使用上下文向DLT守护进程发送日志消息。必须使用日志消息的使用日志级别和参数的变量列表调用DLT_LOG宏。您将在附录API规范中找到完整的参数列表。 DLT_LOG_INT (mycontext DLT_LOG_WARN, num);DLT_LOG_STRING_INT(mycontext,DLT_LOG_WARN, text, num); 作为一种替代方法，可以使用高级日志宏来实现参数的特殊组合。您将在附录API规范中找到完整的列表。 DLT_LOG_ID(mycontext,DLT_LOG_WARN,msgid,DLT_INT(num),DLT_STRING(text)); 对于非详细模式:注册之后，可以使用上下文向DLT守护进程发送日志消息。必须使用日志消息的使用日志级别、消息id和参数变量列表调用DLT_LOG_ID宏。您将在API规范中找到完整的参数列表。 int injection_callback(uint32_t service_id, void \*data, uint32_t length); 高级日志宏在非详细模式下不可用。要使用的一个可选特性是消息注入特性。DLT客户机可以将用户定义的消息发送到应用程序，应用程序由服务id(例如0xfff)标识。如果应用程序接收到这样的消息，则调用回调。回调的格式为: DLT_REGISTER_INJECTION_CALLBACK (mycontext,0 xfff injection_callback); 若要在应用程式内登记回调，必须进行以下调用: DLT_TRACE_NETWORK(mycontext, DLT_NW_TRACE_CAN, headerlen, header, payloadlen, payload); 此外，还可以跟踪网络消息。这里必须指定接口DLT_NW_TRACE_CAN、头数据的长度和指向头数据的指针、负载数据的长度和指向负载数据的指针。如果没有头或有效负载可用，则必须将对应的长度设置为0，并且必须将对应的指针设置为NULL。 DLT_UNREGISTER_CONTEXT (mycontext);DLT_UNREGISTER_APP (); 在使用应用程序和上下文之后，必须从DLT守护进程注销它们。首先是所有上下文，然后必须注销应用程序。 参考genivi的DLT移植 DLT（Diagnostic Log and Trace）嵌入式系统程序运行记录]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>dlt</tag>
        <tag>log</tag>
        <tag>autosar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse C基本操作]]></title>
    <url>%2F2019%2F07%2F26%2Feclipse%2F</url>
    <content type="text"><![CDATA[eclipse 导入 现有工程Project Explorer 右键-&gt;import-&gt; General -&gt; Existing Project into Workspace eclipse 配置工程propertise-&gt;c/c++ build-&gt;settings-&gt;Tool SettingsLibraries 设置依赖库Includes 设置依赖头文件GCC C Compiler-&gt;Command: gcc 后面可以加 参数-&gt;Build Artifactartifact name 生成文件名 生成动态库C++ Project-&gt;Shared Library输入运行参数位置在 debug configure-&gt;arg Linux下Eclipse编译时，报recompile with -fPIC错误，解决方法错误：relocation R_X86_64_32 against `‘。rodata’ can not be used when making a shared object; recompile with -fPIC解决方法是：右键Eclipse工程，propertise-&gt;c/c++ build-&gt;settings-&gt;GCC C Compiler-&gt;Command: gcc 后面加上-fPIC,重新编译]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyqt5笔记]]></title>
    <url>%2F2019%2F07%2F21%2Fpyqt%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[信号槽连接使用Pyqt编程过程中，经常会遇到给槽函数传递额外参数的情况。但是信号-槽机制只是指定信号如何连接到槽，信号定义的参数被传递给槽，而额外的参数（用户定义）不能直接传递。而传递额外参数又是很有用处。你可能使用一个槽处理多个组件的信号，有时要传递额外的信息。一种方法是使用lambda表达式。button1.clicked.connect(lambda: self.on_button(1))解释一下，on_button是怎样处理从两个按钮传来的信号。我们使用lambda传递按钮数字给槽，也可以传递任何其他东西—甚至是按钮组件本身（假如，槽打算把传递信号的按钮修改为不可用）第2个方法是使用functools里的partial函数。button1.clicked.connect(partial(self.on_button, 1)) 按键事件当我们关闭一个窗口时，在PyQt中就会触发一个QCloseEvent的事件，正常情况下会直接关闭这个窗口， #但是我们不希望这样的事情发生，所以我们需要重新定义QCloseEvent，函数名称为closeEvent不可变 pycharm 安装包可以更改源pycharm 可以根据自己使用习惯更改自己常用软件的快捷键]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>pyqt</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式linux系统与主机通过网络传输文件]]></title>
    <url>%2F2019%2F07%2F13%2Flinux%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[1、从服务器上下载文件scp username@servername:/path/filename /var/www/local_dir（本地目录） 例如scp root@192.168.0.101:/var/www/test.txt 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录） 2、上传本地文件到服务器scp 文件名字 服务器用户名字@服务器ip:目录scp /path/filename username@servername:/path例如：scp /var/www/test.php root@192.168.0.101:/var/www/ 把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中例子：scp index.html root@58.87.124.110:/home/service-tomcat/webapps/ 3、从服务器下载整个目录scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录）例如:scp -r root@192.168.0.101:/var/www/test /var/www/ 4、上传目录到服务器同文件上传只是在文件名字前面加上-rscp -r local_dir username@servername:remote_dir例如：scp -r test/ root@192.168.0.101:/var/www/ 把当前目录下的test目录上传到服务器的/var/www/ 目录 注意：1、要在要上传文件的前面加-r，否则报错 static: not a regular file -r: No such file or directory2、要上传文件后面最好加/]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式linux系统与主机通过串口传输文件]]></title>
    <url>%2F2019%2F07%2F13%2Flinux%E4%B8%B2%E5%8F%A3%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、查看串口是否可用 可以对串口发送数据比如对com1口，echo /dev/ttyS02、查看串口名称使用 ls -l /dev/ttyS* 一般情况下串口的名称全部在dev下面，如果你没有外插串口卡的话默认是dev下的ttyS,一般ttyS0对应com1，ttyS1对应com2，当然也不一定是必然的；3、查看串口驱动 cat/proc/tty/drivers/serial4、查看串口设备 dmesg | grep ttyS5、查一下板子上的串口有没有设备 dmesg | grep ttyS* 如果有ttyS设备，再看/dev/有没有ttyS*，如没有就建立一个：mknod /dev/ttyS0 c 4 64 如果板子的设备中没有标准串口设备ttyS0，也没有ttySAC0。/dev下应该有一个USB串口：/dev/ttyUSB0. 当一个串行卡或数据卡被侦测到时，它会被指定成为第一个可用的串行设备。通常是/dev/ttyS1(cua1)或/dev/ttyS2(cua2)，这完成看原已内建的串口数目。ttyS*设备会被报告在/var/run/stab内。 PC上的串口一般是ttyS，板子上Linux的串口一般叫做ttySAC补充:如果需要查看这个串口设备输出cat ttyUSB0 如果需要对这个设备输入echo aaaaa&gt;ttyUSB0 嵌入式linux系统与主机通过串口传输文件我想如果要从PC机下载东西到开发板的嵌入式linux系统里面，很多人首先会想到用tftp sftp等网络工具从网口下载。但如果网络用不了，只能通过串口下载怎么办呢？这个时候有两个工具能帮到你：一个是zmrx、zmtx，另外一个是lsz、lrz。个人觉得zmrx/zmtx没有lsz/lrz稳定，建议还是用后者。下面介绍一下lsz/lrz的使用方法。 一、编译lrzsz并下载到开发板上从http://download.chinaunix.net/download/0007000/6293.shtml下一个lrzsz的tar包，解压缩后输入./configure，然后进入了src文件夹中，修改了src文件夹中的Makefile文件，配置为与手机对应的交叉编译器，运行make，ok！得到两个可执行文件sz，rz（或者 lsz，lrz），把它们下载到开发板linux系统的/bin目录下。 二、情况1: PC机用windows操作系统如果PC机用的是windows操作系统，串口通信工具可以用系统自带的超级终端。下面介绍一下传输文件的方法。 1、开发板–&gt;PC机在开发板上输入 sz filename。在PC机上点击超级终端的菜单“传送”-&gt; “接收文件”，选择下载的位置和Zmodem 与崩溃恢复协议，点击接收即可。 2、PC机–&gt;开发板在开发板上先进入/tmp 目录，然后输入 rz。在PC机上点击超级终端的菜单“传送”-&gt; “发送文件”，选择目标文件和Zmodem 与崩溃恢复协议，点击发送即可。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>串口</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canopen 入门]]></title>
    <url>%2F2019%2F06%2F22%2FCanFestival%2F</url>
    <content type="text"><![CDATA[相对于其他常用的国外开源的CANopen协议栈，CanFestival具有许多明显的优势： CanFestival为开发者提供了许多工具，以提高开发的便利性。例如用于生成节点对象字典源代码的对象字典编辑器，以及便于开发者自由配置编译选项的配置脚本。 CanFestival能够运行于多种类型的平台。CanFestival源代码由ANSI-C编写，驱动和例程的编译情况仅取决于具体的编译工具。在目前最新的版本中，官方提供了对于多种硬件平台的驱动。此外，CanFestival可以在任意类Unix系统下编译和运行，如Linux和FreeBSD。 CanFestival协议功能完整，完全符合CANopen标准。CanFestival完全支持2002年2月发布的CIA DS-301 V4.02标准，并支持CiA DS302中的简明DFC协议 CanFestival 3.0 RC3 源代码的目录结构如下表所示： 文件路径 文件说明 备注 ./src 与处理器无关的的 CANopen 协议栈 ANSI-C 源代码 ./include 针对各处理器的头文件 ./driver 针对各硬件的驱动 ./examples 用于测试的程序 ./objdictgen 带有图形用户界面的对象字典编辑器 ./doc 说明文档 在CanFestival中，所有源代码可以分为四大部分，分别是目标接口、CAN接口、CanFestival库文件以及主/从节点的应用。其中，CanFestival库文件是整个协议的核心，包括调度管理，节点管理（对象字典访问objacces.c、状态机state.c），CANopen协议（服务数据对象sdo.c、过程数据对象pdo.c、同步对象sync.c、自动波特率对象lss.c、网络管理对象nmtMaster.c和nmtSlave.c）。这些文件在移植时是不需要修改的。主/从节点的应用包括节点状态反馈和设备对象字典的定义。目标接口包括节点硬件的驱动以及对于操作系统的接口，这也是进行移植时主要修改的对象。 由于周期性发射同步信号、心跳报文或SDO超时信号需要设定一系列定时信号来提醒系统进行这些工作，所以CANopen节点必须能实现定时功能。CanFestival在timer.c中执行了一个微型调度程序，他可以使用一个定时器来模拟许多定时器。该调度程序会建立并管理一个警报表，并且在规定的时间发出信号。 本次测试中使用的CanFestival用户手册是PDF文档《CanFestival manual_en》。这篇文档详细介绍了CanFestival 工程中各类接口函数、库函数和一些示例应用程序，其中包括利用Canopen协议开发的示例程序。文档还介绍CanFestival的主要特点和理解这个开源工程代码的过程中需要使用的一些工具和分析方法。这是在进行Canopen通信协议开发过程中需要仔细研读的说明文档 CanFestival工程中文件分类及各部分的功能如下图所示： 基于 rt-thread 中 CanFestival 使用入门 使用 rt-thread 中 CanFestival 前期准备：定时器驱动、CAN硬件驱动 配置包， 位于RT-Thread online packages → miscellaneous packages → CanFestival: A free software CANopen framework 编译下载就会可以收发canopen数据了。需要在canopen_recv_thread_entry线程增加延时为了调度 上位机可以通过 CANPRO 解析接收数据和发送数据]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>can</tag>
        <tag>canopen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S32K AUTOSAR 环境搭建]]></title>
    <url>%2F2019%2F06%2F20%2FS32K_AUTOSAR%2F</url>
    <content type="text"><![CDATA[autosar MCAL 下载 安装根据需求在nxp 官网搜索需要的版本下载 和 EB 下载在一个目录下.注意：下载后保存lience autosar OS 下载 安装autosar os 目前只有4.0支持 s32k系列芯片，查找时选择4.0一步一步向下点就能找到下载地址。注意：下载后保存lience EB 简介EB tresos Studio是一个基于Eclipse符合AU-TOSAR标准的车用软件模块配置和代码生成工具环境。通过它，用户可以配置软件模块，验证配置的一致性，以及为标准软件模块(如AUTOSAR标准软件内核)生成代码。 EB tresos下载注意：根据MCAL releasenote中说明下载对应版本。 NXP官网下载链接查找，这个链接找到有点难度，我的方法： 搜索autosar 选择AUTOSAR-4-2: AUTOSAR 4.2.x (Classic Platform) Software 点击下载 选择需要的版本点击下载 进入需要的目录 EB tresos 安装注意：下载时记录lience 安装问题No pagkages were found that can be installed! 解压 下载的 .gz文件 并重命名为 .uip格式。 S32DS 下载注意： 如链接有问题查找 S32DS即可 安装教程：https://blog.csdn.net/zz56z56/article/details/88907425 参考NXP_AUTOSAR_MCAL开发环境搭建引导_S32K14x系列 AUTOSAR各版本对比及模块统计 NXP软件版本介绍]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>S32K</tag>
        <tag>AUTOSAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo github搭建 主题配置]]></title>
    <url>%2F2019%2F06%2F17%2Fhexo%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[参考GitHub+Hexo 搭建个人网站详细教程Hexo 搭建个人博客系列：基础建站篇]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
