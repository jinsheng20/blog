<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[J1939]]></title>
    <url>%2F2020%2F02%2F09%2FJ1939%2F</url>
    <content type="text"><![CDATA[0.SAE J1939概述SAE J1939（以下简称J1939）是美国汽车工程协会（SAE）的推荐标准，广泛用于是商用车（重卡、大客车等道路车辆和工程机械、农业机械、轨道机车、船舶等非道路车辆及设备）上电子部件间的数字通讯。它由SAE“卡车与大型客车电气与电子委员会”（Truck &amp; Bus Electrical &amp; Electronics Committee）下属的“卡车与大型客车控制和通讯网络附属委员会”（Truck &amp; Bus Control and Communications Network Subcommittee）开发编写。 J1939基于德国Bosch公司在上世纪80年代开发的控制器局域网络（Controller Area Network，CAN）， CAN总线。CAN总线描述了一种车辆各控制单元之间不分主从节点的通信网络， 各控制单元之间通过报文通信。 J1939描述了CAN总线的一种网络应用，包括CAN网络物理层定义、数据链路层定义、应用层定义、网络层定义、故障诊断、和网络管理。在SAE J1939协议中，不仅仅指定了传输类型、报文结构及其分段等，而且报文内容本身也做了精确的定义， 下面对它们详细进行描述。 SAE J1939 不同于在乘用车行业的CAN通信协议。乘用车行业的CAN通信协议没有统一的行业标准， 基本上由各主机厂依据自己的需要进行定义， 这给主机厂之外的应用人员带来了一定的困难。 而商用车行业的SAE J1939 已成为了全球标准， 除了一些用于保密的厂家私有报文之外， 所有车辆运行参数的报文解析都是公开的， 比如发动机转速、发动机水温、发动机负荷比都可以通过标准报文解析获得。 1. J1939 网络各层介绍1.1 J1939物理层：J1939-11 定义了波特率为250 kb的带屏蔽的三线物理层， 网络主干可达40米长，可挂40个节点；J1939-15 定义了波特率为250 kb的不带屏蔽的两线物理层，网络主干可达40米长，可挂10个节点；还有一个J1939-14定义波特率为500 kb的物理层，目前还没正式推出。 1.2 J1939数据链路层（基于J1939-21）：J1939 使用一个较简单的数据链路来通信。 如下表所示， 29为CAN ID包括Priority (P), Extended Data Page (EDP), Data Page (DP), Protocol Format （PF）, Protocol Specific (PS), 和 Source Address （SA）六个部分。 | P | EDP | DP | PF | PS | SA || ——– | —–: | :—-: || 3 bits | 1 bit | 1 bit | 8 bits | 8 bits | 8 bits |P 是优先级, EDP 和 DP 构成不同的4个数据页， 其中一页为ISO 15765-3 预留。PF 和 PS 定义参数组数和目标地址, SA 是源地址。 1.3 J1939网络层（基于J1939-31）：描述两个网络部分间针对报文传输的网桥的功能，并且只与 J1939网桥实现相关。 1.4 J1939应用层（基于J1939-71）：描述实际的数据 (参数或带有值域的网络变量、分辨率、物理单元和传输类型) 。每个报文无歧义地对应一个数(参数组数) 。 1.5 J1939网络管理（基于J1939-81）：可以被当作一个分离的单元，能直达第一层，因此在这个层模型中，该模块是作为右手边的一个独立的功能块。网络管理基本上包括自动分配或决定节点地址(即插即用原则)。在SAE J1939中没有定义节点监视，因而必须在应用时通过循环报文实现。 1.6 J1939诊断（基于J1939-13/73）:2. J1939 应用介绍2.1 J1939 报文J1939 报文的核心是Parameter Group Number (PGN)。每个报文的PGN 都是独特的， 用于区分报文和其数据。 尽管有时候一个报文只包含一个参数（如车架号VIN），一般来说，一个报文会含有多个参数。 整个J1939 一共有8672 个PGN。现以PGN 61444 表示的报文为例， 它表示发动机控制单元报文ECU1。 这个报文含有7个不同的参数， 发动机转速值是其中之一。 2.2 J1939 报文长度J1939 允许使用3种不同的报文长度： 3字节、8字节、变长度。 其中， 3字节报文只有一个报文， 那就是请求报文， PGN 59904；绝大多数的报文时8字节，这让网络带宽得到最有效地使用；变长度报文指长度在9字节到1785个字节，这样的报文太长无法放进一个单独的数据帧， 所以必须分解放进不同的数据帧，在接收端再完成重组， 这个步骤由 J1939 的传输协议层里定义。传输协议层定义了两种不同类型的分解方法：BAM和CM。 这两种分解方法有几个不同点， 最主要的是： 1， 目标地址不同，BAM使用全局地址而CM使用特定地址， 正由于寻址上的区别，BAM一次只能发送一个而CM一次可以发送多个。 2， 发送需要的时间不同，BAM 个数据包之间得间隔不短于50毫秒且不超过200 毫秒， 而CM类型的数据包可以发送越快越好。 2.3 J1939 节点命名J1939 网络上的每个电子控制单元（Electronic Control Unit, ECU）都有一个独一无二的名字。 这个名字64位宽， 由下面这几部分组成：Arbitrary Address Capable, Industry Group, Vehicle System Instance, Vehicle System, Reserved Bit, Function, Function instance, ECU Instance, Manufacturer Code, and Identity Number。 这个名字给予每个ECU一个类似于身份样的东西，J1939 网络上的各节点通过这样的名字来互相区分。这个名字也在网络管理上简历优先级。这个64位的名字以数字来表示， 在地址声明时， 这个数字代表优先级， 数字越小优先级越高。 一个有意思的现象： 有时候一个ECU硬件可以包含多个J1939 网络节点， 也就是一个硬件有多个名字。 2.4 J1939 地址声明在J1939 网络上， 一个节点必须先成功声明一个地址才能启动通信。地址0-128是预先分配好了的， 使用这些地址的节点一上电就可以启动通信。 考虑到将来的节点和功能，J1939 采用了一个动态分配地址的方法。 新接入J1939网络的节点必须先成功为它自己声明一个地址才能发送和接受消息。 当一个新节点要声明地址时， 它发送一个地址声明消息， 该消息含有它想要的地址， 此时， 网络上所有的节点那这个地址和它们自己的地址表进行比较。如果某个高优先级节点正在使用该地址， 这个高优先级节点就说这个地址已经被使用，这个新节点不能声明这个地址， 这次地址声明不成功。如果某个地优先级节点正在使用该地址， 这个低优先级节点立即放弃这个被声明的地址， 然后自己再去声明一个新的， 这个新节点的地址声明成功。 3. J1939 协议栈什么是J1939协议栈？J1939协议栈是一个完整的软件包，该软件包可以处理J1939 各层内容。 简单来说， 对所有要发送的数据， 该软件包负责将应用软件里的数据进行转换、分解、然后把CAN数据帧发送到J1939 网络； 对所有要接收的数据， 该软件包负责从J1939 网络接收、转换、重组， 然后提供给应用软件。1.6 J1939诊断（基于J1939-13/73）:]]></content>
      <categories>
        <category>J1939</category>
      </categories>
      <tags>
        <tag>CAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[autosar com]]></title>
    <url>%2F2020%2F02%2F09%2Fautosar%20com%2F</url>
    <content type="text"><![CDATA[关于AUTOSAR的底层驱动、平台OS、平台应用、RTE、应用软件这些和VxWorks653很相似，就不多赘述了。此处说一下AUTOSAR独有的网络通讯规范和网络管理模块NM AUTOSAR COM是AUTOSAR标准的一部分，它是从OSEK COM标准的基础上发展而来的。AUTOSAR COM提供了一种标准化的访问汽车通讯系统和ECU（Electronic Control Unit）通讯的方式，提出了一个在不同速率的总线网络之间进行数据交换的方法。它为汽车控制单元应用软件提供了一个统一的通信环境，为内部和外部通信定义了公共的软件通信接口和行为，增强了应用软件模块的可移植性。 依据AUTOSAR的描述，这个跟IMA的RDIU很类似。实现不同数据协议和速率的数据的相互装换，然后发向目的ECU。 AUTOSAR COM提供了基本的通信服务，它有明确的上层模块RTE(Runtime Environment)和下层模块PDU Router。 在发送过程中，应用层调用COM层提供的信号或信号组发送函数，根据配置，信号或信号组的数据经过字节顺序转换后被更新到I-PDU（Interaction Layer Protocol Data Unit）中相应的位置中。AUTOSAR COM规范中同一I-PDU可以设置两种发送模式，对其中各信号的传输模式条件进行计算，I-PDU选择其中一种发送模式进行发送。然后启动发送死限监控，调用PduR_ComTransmit()函数将I-PDU发送到底层。 在接收过程中，当底层接收到I-PDU时，底层将调用COM层提供的指示函数Com_RxIndication()，取消并重启接收死限监控，将I-PDU的数据从底层拷贝到COM中。调用信号或信号组的接收函数后，该I-PDU中的信号或信号组将经过字节顺序转换、符号扩展和接收过滤后，数据被拷贝到应用层。 通信系统核心模块的实现通信系统主要实现信号或信号组的收发功能，以下主要介绍信号发送的实现。首先简要介绍一下AUTOSAR COM中特有的传输模式切换。 传输模式切换AUTOSAR COM规范定义了4种信号传输模式： 直接/N次传输模式 周期传输模式 混合传输模式 None传输模式 在AUTOSAR COM规范中允许为每个I-PDU静态配置两种不同的传输模式。 在AUTOSAR COM规范中通过传输模式切换，来选择I-PDU中的其中一种传输模式进行传输。 首先使用过滤机制判断I-PDU中各信号的发送模式条件，同时更新I-PDU中的信号； 再通过各信号的判断结果来计算该I-PDU的TMS（transmission mode selector）。若至少有一个C( Si,IPDUk)为True，则TMS为True；若所有C(Si,IPDUk)都为False，则TMS为False。其中C(Si,IPDUk)为传输模式条件该条件与IPDUk中的信号Si相关。 下面通过一个用例简要说明传输模式的切换。 用例中进行周期传输和直接/N次传输之间的切换（N=3）。根据I-PDU的传输配置，当TMS（transmission mode selector）判断为真时，设置传输模式为周期传输，反之为直接/N次传输。上层给定值V=a（此时TMS判断为真），进行周期传输；当值V更新为b时（此时TMS判断为假），进行直接/N次传输模式，传输三次。由图3可知，随着V值的更新该I-PDU的传输模式在这两种传输模式之间切换。 信号发送的实现 首先根据该信号的相关配置，判定其是内部消息还是外部消息。对于内部发送，直接将信号数据复制到接收信号数据区，并执行通知操作；对于外部发送，若该信号发送属性为触发，则该信号所属的I-PDU将立即发送（除非该I-PDU发送模式为周期传输模式），若该信号发送属性为延迟，则不进行传输，发送时，信号经过字节顺序转换后数据被复制到I-PDU中，同时设置相关更新位信息，然后根据该I-PDU的TMS切换传输模式，进行传输并设置启动相关定时器。各传输模式的传输过程与OSEK COM中大致相同。 信号接收的实现 首先判定是内部信号还是外部信号。对于内部接收，直接将信号数据复制到接收信号数据区；对于外部接收，首先判断对于的I-PDU组是否启动，若启动，返回E_OK，否则返回COM_STOP，取消并重启该I-PDU的相关死限监控定时器，将数据复制到I-PDU数据区，I-PDU中的信号经过字节书序转换、符号扩展和过滤机制后，复制到接收信号数据区，再执行通知操作，通知上层软件调用相关API函数接收信号。]]></content>
      <categories>
        <category>autosar com</category>
      </categories>
      <tags>
        <tag>autosar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[autosar NM(网络管理)]]></title>
    <url>%2F2020%2F02%2F09%2Fautosar%20NM(%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86)%2F</url>
    <content type="text"><![CDATA[这里的NM主要是针对Can协议的网路管理。 AUTOSAR CanNM的核心思想主要归纳为以下两条： 如果节点需要保持通信，则节点需要周期的发送NMPDUs，否则停止发送NMPDUs 如果总线上的所有节点不需要使用总线，那么总线上过了一段时间没有NMPDUs时，则会进入Bus-Sleep Mode。 工作模式和状态 CanNm一共有三个工作模式 Network Mode PrepareBus-Sleep Mode Bus-Sleep Mode 模式的改变应该通过回调函数通知上层。 下面单独说每种模式 （1）Network Mode Network Mode又包括三个内部状态 Repeat Message State Normal Operation State Ready Sleep State ①Repeat Message State 这个模式被用来确保从Bus-Sleep or Prepare Bus-Sleep到Network Mode的节点被总线上面其他节点发现。这个状态可以用来检测总线上的节点。当进入Repeat Message State时，节点应该开始传送NMPDUs。在Repeat Message State时，当NM-Timeout Timer溢出，CanNm模块应该重载Timer。CanNm模块应该在Repeat Message State 下保持一段时间，这段时间可以通过CANNM_REPEAT_MESSAGE_TIME来进行配置。当离开Repeat Message State的时候，如果节点需要通信，则进入Normal Operation State；如果节点不需要通信，则进入Ready Sleep State。并且清空Repeat Message Bit。 ②Normal Operation State 这个状态可以保持总线处于唤醒状态。从Ready sleep state进入这个状态的时候应该发送NMPDUs。在Normal Operation State当NM-Timeout Timer溢出，CanNm模块应该重载Timer。如果节点不需要使用通信，则网络应该被释放，节点应该进入Ready Sleep State。如果节点接收到Repeat Message Request Bit，则节点进入Repeat Message State。如果节点自身需要进入Repeat Message State，则该节点进入Repeat Message State并且设置Repeat Message Request Bit。 ③ReadySleep State 这个状态是为了如果本节点已经准备释放总线，而其他节点还需要使用总线的时候，在这个状态下等待其他总线上的节点进入Perpere Bus-Sleep Mode。进入这个状态之后，CanNm模块应该停止NMPDUs的传送。如果NM-Timeout Timer溢出，节点将会进入Prepare Bus-Sleep Mode。如果该节点需要使用总线，则节点进入Nomal Operation State。如果节点接收到Repeat Message Request Bit，则节点进入Repeat Message State。如果节点自身需要进入Repeat Message State，则该节点进入Repeat Message State并且设置Repeat Message Request Bit。 （2）PrepareBus-Sleep Mode 这个状态是为了等待总线上的所有节点能够在进入Bus-Sleep Mode之前，有时间停止节点的active状态如清空队列中为发送的报文。在Prepare Bus –Sleep Mode下，所有节点都静默下来。 当节点进入PrepareBus Mode时，应该通知上层应用。通过配置CANNM_WAIT_BUS_SLEEP_TIME参数，可以改变节点在PrepareBus-Sleep Mode停留的时间，在这段时间之后节点将会进入其他状态。 在Prepare Bus-Sleep Mode下面接收到NMPDU或者被上层应用请求通信时，节点将进入Network Mode中的Normal operation State。 （3）Bus-SleepMode Bus-Sleep Mode的目的是当没有消息被传送的时候可以减少能量的消耗。在Bus-Sleep Mode下面，节点可以被唤醒（如本地唤醒源和CAN线唤醒源）。CANNM_TIMEOUT_TIME+CANNM_WAIT_BUS_SLEEP_TIME两个参数在整个总线上面的节点都应该时一样的配置，保证了总线上的节点能够统一的进行休眠。 当进入Bus-Sleep Mode时候，应该通知上层应用。 在Bus-Sleep Mode下，如果成功接收到NMPDU，CAN NM模块应该调用Nm_NetworkStartIndication。 如果CanNm_PassiveStartUp被调用，则CAN NM模块进入Network Mode 中的Repeat Message State AUTOSAR CAN NetworkManagement 所管理的唤醒源分为2种 1.Active Wake up 主动唤醒：ECU 作为主唤醒节点，当检测到主动唤醒源输入信号时（如KL15）主动唤醒自己，并通过发送NMFRAME 尝试唤醒其他ECU 2.Passive Wake up 被动唤醒：ECU 作为从唤醒节点，自己不能主动唤醒自己，只能通过接收到其他 ECU发来的NM FRAME来唤醒自己 AUTOSAR CAN Network Management 介绍Network Requested:检测到主动唤醒源输入信号，请求切换至主动唤醒模式 Network Released:检测到主动唤醒源输入信号丢失，请求切换至被动唤醒模式（有时在接收到NMFRAME 中包含的CBV也可作为主动唤醒源的输入信号） 结合上图，详谈CANNetwork Management中的mode 和 state是如何切换的！ 全被动唤醒状态流向 NM_01àNM_02àNM_08àNM_09àNM_12 全主动唤醒状态流向 NM_01àNM_03àNM_05]]></content>
      <categories>
        <category>autosar NM</category>
      </categories>
      <tags>
        <tag>autosar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux应用学习笔记]]></title>
    <url>%2F2020%2F02%2F09%2Flinux%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[虚拟网卡设置###（1）桥接模式在桥接模式下，虚拟系统和宿主机器的关系，就像连接在同一个Hub 上的两台电脑。 在进行嵌入式Linux 开发，要目标板通过NFS 挂载虚拟机的NFS 共享目录的话，必须将虚拟网卡配置为桥接模式。 ###（2）NAT 模式使用NAT 模式，就是让虚拟系统借助NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网。 采用NAT 模式最大的优势是虚拟系统接入互联网非常简单，用户不需要进行任何其它的配置，只需要宿主机器能访问互联网即可。 ###（3）仅主机模式在某些特殊的网络调试环境中，要求将真实环境和虚拟环境隔离开，这时用户就可采用仅主机（Host-Only）模式。 硬链接：简单把它想成 C 语言中的指针硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。 用于NOR Flash 的jffs2 和用于NAND Flash 的yaffs/yaffs2、ubifs 等]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[obd诊断协议]]></title>
    <url>%2F2019%2F08%2F27%2Fobd%E8%AF%8A%E6%96%AD%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[本文链接：https://blog.csdn.net/AgingMoon/article/details/78225200本篇文章主要从以下几个方面进行讲解 1.OBD用来做什么2.OBD和UDS的区别3.OBD硬件接口简介4.OBD的9大模式介绍OBD（On-Board Diagnostic）指的是在线诊断系统，是汽车上的一种用于监控车辆状况以及控制排放的一种在线诊断系统。本篇文章主要围绕OBD的九种模式进行介绍，当然也会辅助介绍一些OBD相关的内容。 1.OBD用来做什么对于一般的车主，可能有接触过OBD口，可以用它来查看一些车内的参数等等，但是OBD它到底用来做什么用呢？ 还是以一贯的思路，进行分点说明 a.用于监控车辆基本参数，例如监控里程、车速、油门踏板位置、冷却液温度等等的一些参数； b.用于监控排放相关的参数，这是OBD很核心的一个功能，比如各种尾气的含量，氧含量等等，以此来保证满足各国的标准； c.用于车辆故障的诊断，例如我们车故障灯亮了，送到维修店后，维修人员就会拿出诊断仪，请求发生的故障内容，以及故障时刻的冻结帧数据，以此来方便故障排查； d.当然还有小部分会使用OBD进行一些控制功能，这部分在中国是没有的。 2.OBD和UDS的区别大家看过我前面的文章的话，也有对UDS进行介绍，那么UDS和OBD都是车上诊断的标准，他们有什么区别呢？首先从适用对象来说，OBD出现的更早，那么它主要针对传统燃油车，并且OBD主要是用于排放相关的诊断，而UDS是统一诊断系统，那么它的适用性则更广一点，它囊括了非排放相关的车身上所有ECU的诊断。可以简单的理解OBD就是用于排放相关的ECU，如发送机控制单元，减速器控制器等；而UDS则包含了车身上几乎所有ECU的诊断，例如VCU BCM DCDC等等。第二点：也是因为他们适用对象的不同，所以他们支持的服务是不一样的，这点看标准就知道了。稍微总结一下就是OBD主要用于与排放相关的ECU的诊断，而UDS则是排放除外的其他ECU的统一诊断标准。OBD的使用对象主要是传统燃油车中排放相关的ECU，而UDS使用对象既可以是燃油车中的ECU也可以是混动纯电动中的ECU。一般传统燃油或混动车中与排放相关的ECU既要支持OBD也要支持UDS，而其他的ECU一般仅仅需要支持UDS。3.OBD的硬件接口简介 从图中我们也知道，各个引脚之间的关系，那么这个端口也是通过国际标准进行定义的OBD-II端口，在使用时，我们需要买对应的端口来进行与汽车诊断端口进行通信。 一般汽车这个诊断端口在我们的方向盘下面，油门踏板上面（不同厂家可能不一致）。 4.OBD的9大模式（服务）介绍为了能够快速的了解OBD的各个模式，以下针对每个模式从2方面进行介绍； 1).模式的作用（使用场景） 2),模式如何使用 a.模式1-请求动力系统当前数据1).模式的作用 从这个定义我们就了解到，通过该模式我们可以去请求车辆上动力系统的一些数据，但是这些数据都是需要预先定义好的，如何进行定义呢，那么ISO标准规定了一些参数标识符即PID（parameter Identifiers），每个PID代表一个变量参数，但是呢在CAN上传输怎么去识别这个参数呢，其实就是顶一个8bit的数据来代表这个参数，比如PID 0x01 表示DTC清除后的监控状态，比如PID 0x05 表示电机冷却液的温度 ，那么ISO15031-5它定义了很多这样的PID参数，这样定义是很有意义的，因为这可以保证所有厂家的OBD可以尽可能的统一，从而方便通用。 我们稍微总结一下，模式1的作用就是 通过预先标准定义好的一些PID参数，去请求动力系统当前的一些数据（如速度、里程、温度等），以此来了解当前车辆的一些状态。 2).模式如何使用 ISO其实定义了很多PID参数，但是并不要求所有的主机厂把这些参数都实现，也就是说PID参数是可以选择支持的。那么我们怎么知道这个厂家支持哪一些参数呢？其实模式1中它有一些PID 0x00\0x20\0x40\0x60\0x80等就是用来查询到底支持哪些服务的。具体如何使用如下： PID 0x00 用于查询（0x01~0x20）之间支持的PID参数 PID 0x20 用于查询（0x21~0x40）之间支持的PID参数 PID 0x40 用于查询 （0x41~0x60）之间支持的PID参数 以此类推后面的0x60 0x80 使用第一步：查询支持的PID参数（req表示请求（request），res表示答复（response）） req：01 00 res：41 00 xx xx xx xx 左起第一个xx表示0x01~0x08之间的PID支持情况 将xx转为2进制 如xx=0x65 -&gt;xx=0110 0101 从左往右 那么表示支持PID 0x02 0x03 0x06 0x08 左起第二个xx表示0x09~0x10之间的PID支持情况 按照同样的转化方式 左起第三个xx表示0x11~0x18之间的PID 支持情况 按照同样的转化方式 左起第四个xx表示0x19~0x20之间的PID支持情况 按照同样的转化方式 是不是0x00就是查询0x01~0x20之间支持的PID情况？ 同理对0x20 0x40等进行查询 使用第二步：就可以读取相关支持的PID参数的值了，假如支持PID 0x04 0x05 0x0d req:01 04 05 0c res:41 04 xx xx 05 xx 0d xx 其中xx表示支持的PID的值了，比如0d表示当前的车速，0d后面的xx的值是64，及对应的是100KM/h，即请求到的车速为当前100km/h 多说几句就是我们可以每次只请求一个PID，也可以一次请求多个，最多6个，而答复的话可能不会按照顺序来，如果在CAN上，答复的数据超过8个byte的话，那么它就会分出几个帧来进行答复。 b.模式2-请求冻结帧数据1).模式的作用 首先解释一下冻结帧，所谓的冻结帧你可以理解为故障发生时刻的一些环境数据，冻结帧的存在就是为了尽可能了解故障发生时的一些参数，以此来方便分析故障。 因此我们可以这样说模式2的作用就是为了快速方便的了解，故障发生时刻的一个状态，以此来分析、排查以及定位故障，从而能够有效的提高售后维护的效率。 2).模式的使用 使用第一步：和模式1一样，先要查询支持的冻结帧的PID参数，格式也和模式1类似。 使用第二步：因为冻结帧是因为故障发生导致存储的，因此我们先要知道导致存储的冻结帧的故障码是什么。 req:02 02 xx //这里xx表示帧序号 res:42 0x xx xx xx //左起 第一个xx表示帧序号，第二个xx 表示DTC（故障码）高字节 第三个xx 表示DTC（故障码）低字节 使用第三步：请求相应的冻结帧数据，比如支持PID 0x0C(速度) 0x05（温度）参数 ,请求frame 00 req:02 0c 00 05 00 //这里00表示frame 00 res:43 0c 00 xx xx 05 00 xx 这里左起前两个xx表示速度 后面的xx表示温度 c.模式3-请求排放相关的故障码1).模式的作用 首先我们了解一下故障码，所谓的故障码就是代表某一种故障的代码，比如氧气传感器短路的故障码为P0130 那么这些故障码在IDS15031-6中都有定义，对应can报文上两个字节DTC_H 和DTC_L 例如这里的P0130 对应的DTC_H = 0x01 DTC_L=0x30。 那么模式3的作用就是请求当前确认的故障（Comfirmed DTC）的故障码，以此就可以了解车辆发生故障时，是哪个故障导致的，进而就可以根据该故障的机理来分析故障，维修车辆。 2).模式的使用 req:03 res:43 03 01 41 01 45 01 48 // 03表示DTC的个数，后面三对颜色表示三个故障码P0141 P0145 P0148 如果没有故障则会回复 00 00… d.模式4-清除排放相关的故障信息1).模式的作用 为啥要清除故障信息呢，因为车子在出厂后，我们不能让车故障灯亮着就出厂吧，这是其一，其二就是每次维修好之后，有必要将故障清除掉，表示该故障已经解决，还有就是可以腾出内存空间，以便后续发生的故障进行存储。 2).模式的使用 该模式的使用比较简单； req:04 res:44 就算没有故障，也会返回正响应；注意这里清除的数据比较多，包括故障码、冻结帧、测试数据等等排放相关的内存数据都会清除掉。 e.模式5-请求氧传感器的检测结果1).模式的作用 显然根据名字我们就可以知道，这个模式的作用就是监控氧传感器的测试结果，因为氧气的浓度对燃烧过程有着重要的影响，因此对排放也有着重大的影响，因此有必要进行测试监控。一般支持模式6的话也可以通过模式6来代替模式5的功能。 2)模式的使用 使用第一步：查询支持的氧传感器支持的测试表示符TID（Test Identifiers），这是TID也在IDS15031-5的附录中有定义。如模式1和2查询PID一样，模式5查询TID也是类似使用0x00…来查询； 使用第二步：通过PID 0x13 0x1D来查询氧传感器的位置，因为动力系统模块中，可能多个地方都有O2传感器，如图定义了字节信息对应传感器的位置 使用第三步:查询氧传感器的测试结果， 根据第一步获得的TID 如0x05 和第二步获得的O2传感器位置0x01，那么就可以进行获取氧传感器的测试结果。 req:05 05 01 res:45 05 01 12 00 19 //这里的12表示测试结果，00表示测试结果范围的最小值，19表示测试结果范围的最大值。 f.模式6-请求指定监控系统的测试结果1).模式的作用 车上不仅仅氧传感器的结果需要监控，还有其他很多的地方需要结构，比如催化剂、蒸发系统等等，那么可以通过模式6来进行监控。 那么主机厂也可以根据需要去定义监控各个系统模块ID以及需要进行测试的参数TID。 2).模式的使用 使用第一步：也是查询支持的TID 使用第二步：查询支持的组件ID（若有的话） 使用第三步：请求测试结果 比如 TID 0x11 模块ID 0x01 req:06 11 res:46 11 01 xx xx xx xx //左起前两个xx表示测试结果，后两个xx表示测试值的限制值，意思就是表示测试结果是否在范围内。 g.模式7-请求当前或上一驱动周期检测到的排放相关的故障码1).模式的作用 为啥有了03请求故障码，还需要07模式呢，我们可以看到，03模式主要请求的是确认的故障码（比如一个故障发生后，需要连续3个驱动周期才能发展为确认的故障），而这里07模式表示的是当前的或上一驱动周期发生的故障（这里强调的是上一驱动周期或当前驱动周期发生的，意思是pending），以上是他们请求的故障码的区别。那么需要请求pending类的故障呢？这是因为，每次维修人员修理完之后，会清理故障，为了了解这个故障是不是真正解决了，就需要重新试一下，然后看这个故障是不是又会出现，如果是通过模式3去了解，则至少需要三个操作循环，而模式7则可当前操作循环就可以知道。 总结一下可以这么说07模式就是帮助技术员快速了解故障问题是否解决。 2)模式的使用 同03模式，可参考03模式。 h.模式8-请求控制在线系统或组件1).模式的作用 因为这个模式使用的比较少，比如我国的所有OBD是不支持08模式的，以下对其进行简单的介绍。 这个模式就是通过定义测试标识符TID以及测试数据，去操作ECU进行测试。 2).模式的使用 如定义了TID 0x01 测试数据 00 00 00 00 00 req:08 01 00 00 00 00 00 res:48 01 00 00 00 00 00 i.模式9-请求整车信息1)模式的作用 大家知道车辆中，有一个很重要的信息就是VIN码，也就是车辆标识码，这个码可是这辆车的“身份证”，那么我们怎么读这个身份证信息呢，这就需要我们使用09模式了。 此外还包括一些标定ID 标定校验ID ECU名称 IPT等信息可以通过09模式来读取。 2)模式的使用 和前面提到的PID TID一样，这里定义了一个叫InfoType的，你可以理解为消息类型，其实也同样是用一个byte来表示某个信息，比如infoType = 0x02表示VIN码这个信息。 使用第一步：类似查询支持的PID TID一样，这里第一步也是查询支持的InfoType； 使用第二步：根据支持的InfoType来请求其对应的值，如请求VIN码 0x02为例 req:09 02 res:49 02 32 31 47 53 78 98 27 18 38 38 85 92 92 82 71 82 92 //这里标红部分就是VIN的内容，如果是CAN的话会采用多帧传输，这里仅仅是示意。 以上主要针对OBD进行说明，更多具有价值的是读者去体会和使用其中提到的PID TID以及InfoType，经过几次使用之后会对这个协议会有更深的理解。]]></content>
      <categories>
        <category>CAN</category>
      </categories>
      <tags>
        <tag>诊断协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qt应用]]></title>
    <url>%2F2019%2F08%2F13%2Fqt%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[lcdnumber 显示系统时间#include &lt;QTimer&gt; QTimer *timer = new QTimer(this); connect(timer,SIGNAL(timeout()),this,SLOT(on_systemTimeDisplay())); timer-&gt;start(200); //200ms 获取一次 ui-&gt;lcdNumber-&gt;setDigitCount(8); //显示数字数量，包括‘：’ ui-&gt;lcdNumber-&gt;setMode(QLCDNumber::Dec); //设置10进制显示 ui-&gt;lcdNumber-&gt;setSegmentStyle(QLCDNumber::Flat); void Widget::on_systemTimeDisplay() { QTime current_time = QTime::currentTime(); ui-&gt;lcdNumber-&gt;display(current_time.toString(&quot;hh:mm:ss&quot;)); }QT 延时QTime t; t.start(); while(t.elapsed()&lt;1000) QCoreApplication::processEvents(); //不停地处理事件，以使得程序保持响应。 QThread::sleep(1); //线程延时时间widget窗口设置Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) { ui-&gt;setupUi(this); //hide frame 全屏显示去掉最大化最小化关闭 this-&gt;setWindowFlags(Qt::FramelessWindowHint); //fix widow size this-&gt;setFixedSize(1280,1024); //set pos to center this-&gt;move(0,0); }QlineEdit 设置不可编辑并更该默认显示样式ui-&gt;lineEdit-&gt;setEnabled(false); QLineEdit:disabled{background-color: rgb(255, 255, 255);} //设置不可编辑样式qt显示图片或者图片流QString filename(&quot;xx.jpg&quot;); QImage* img = new QImage; if(! ( img-&gt;label(filename) ) ) //加载图像 { delete img; return; } int width = ui-&gt;label-&gt;width(); int height = ui-&gt;label-&gt;height(); QImage ime = img-&gt;scaled(width, height);//自定义缩放 ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(ime)); ui-&gt;label-&gt;show();qt 数据类型转换//int to string QString::number((xx), 10) //double to string QString::number((xx), 10, 3) //保留3位小数 10进制qt 日志打印输出qDebug : 调试信息提示 qWarning: 一般的警告提示 qCritical: 严重错误提示 qFatal: 致命错误提示qt 槽函数 使用自定义数据类型方法如果要在Qt信号槽中使用自定义类型，需要注意使用qRegisterMetaType对自定义类型进行注册，当然在不跨线程时使用自定义类型signal/slot来传递，可能不会出现什么问题；一旦涉及跨线程就很容易出错，回想下信号槽的作用就是用来对象与对象之间通信的，难免会跨线程，建议在使用自定义类型利用信号槽通信时，最好先通过qRegisterMetaType()将自定义类型进行注册，以免出错。 总结qRegisterMetaType使用方法如下： 1、注册位置：在第一次使用此类链接跨线程的signal/slot之前，一般在当前类的构造函数中进行注册； 2、注册方法：在当前类的顶部包含：#include ，构造函数中加入代码：qRegisterMetaType(“Myclass”)； 3、Myclass的引用类型需单独注册：qRegisterMetaType(“Myclass&amp;”)； qt 异常错误查找方法$ ./test Floating point exception (core dumped) $ dmesg [0.032980] traps: test[122] trap divide error ip:420211 sp:7ffc221f0290 error:0 in test[400000+2000] $ addr2line -e test 420211 ~/test/test.c:10 addr2line显示第10行除零错误。程序需要加-g编译debug版本才行，否则命令无法显示行：??:?，因为addr2line是通过查找调试信息定位到行的。 readelf -w test readelf查看符号表 elf 文件查看利器qt widget 窗口设置this-&gt;setWindowFlags(Qt::FramelessWindowHint); //设置去掉最大最小外边框 this-&gt;move(760,550); //设置 窗口位置 this-&gt;setFixedSize(500,460); //设置窗口大小 this-&gt;setWindowFlags(Qt::WindowStaysOnTopHint); //设置窗口一直保持在顶端 this-&gt;hide(); //设置窗口隐藏qt 设置控件不显示setVisible(false) ComboBox控件当选择其中一项时可以通过下面的函数进行处理事件（槽函数）控件槽函数写法 void Widget::on_控件名_信号()void Widget::on_SensorTypeComboBox_activated() 设置默认选中行ui-&gt;listWidget-&gt;setCurrentRow(2);]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vtk使用]]></title>
    <url>%2F2019%2F08%2F13%2Fvtk%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vtk 和 pcl 资源网址Point Cloud Library (PCL) Users mailing listPoint Cloud Library (PCL) Users mailing list 包含问题的解答http://www.pcl-users.org/ vtk example官方vtk官方使用文档vtk官方库接口说明 pcl官方库接口说明 pcl 博客https://www.cnblogs.com/li-yao7758258/p/6476046.htmlhttps://www.cnblogs.com/flyinggod/category/1180338.html VTK 代码片段vtk 显示坐标系//vtk 设置显示坐标系（坐标系颜色深红色 x轴 绿色 y轴 蓝色 z轴 #include &lt;vtkAxesActor.h&gt; // #define LINE_LEN 1 vtkSmartPointer&lt;vtkAxesActor&gt; actor2 = vtkSmartPointer&lt;vtkAxesActor&gt;::New(); actor2-&gt;SetPosition(0, 0, 0); //设置原点 actor2-&gt;SetTotalLength(LINE_LEN, LINE_LEN, LINE_LEN); //设置单位长度 actor2-&gt;SetShaftType(0); actor2-&gt;SetAxisLabels(0); actor2-&gt;SetCylinderRadius(0.02);vtk 物体位置角度设置vtkSmartPointer&lt;vtkTransform&gt; trans = vtkSmartPointer&lt;vtkTransform&gt;::New(); trans-&gt;PostMultiply(); trans-&gt;Translate(position-&gt;x, position-&gt;y, position-&gt;z); //移动位置 trans-&gt;RotateX(position-&gt;roll); //沿X轴旋转x度 trans-&gt;RotateY(position-&gt;pitch); //沿Y轴旋转x度 trans-&gt;RotateZ(position-&gt;yaw); //沿Z轴旋转x度 trans-&gt;Scale(0.5,0.5,0.5); //实际实物缩放比例 actor-&gt;SetUserTransform(trans);vtk相机位置vtkSmartPointer&lt;vtkCamera&gt; camera = vtkSmartPointer&lt;vtkCamera&gt;::New(); camera-&gt;SetPosition(0, -1, 0); //相机位置 camera-&gt;SetFocalPoint(0, 0, 0); //焦点 camera-&gt;SetViewUp(0, 0, 1); //相机方向 camera-&gt;Azimuth(150); camera-&gt;Elevation(30); camera-&gt;ComputeViewPlaneNormal(); //根据设置的相机位置、焦点等信息，重新计算视平面(View Plane)的法向量 renderer-&gt;GetActiveCamera()-&gt;Dolly(0.1); //显示缩放比例，实际坐标并未改变。pcl 设置相机位置viewer2-&gt;setCameraPosition(30, 0, 15, 1, 0, -1, 0, 0, 1); //前三个x,y,z,中间 x旋转角度， y旋转角度， z旋转角度， 最后三个取值（-1，1）向上方向pcl 点云数据平移 旋转#include &lt;vtkTransform.h&gt; //两种实际改变点云位置的点云移动 注释部分没有验证 // //构造变化矩阵 // Eigen::Matrix4f transform_1 = Eigen::Matrix4f::Identity(); // float theta = M_PI/4; //旋转的度数，这里是45度 // // transform_1 (0,0) = cos (theta); //这里是绕的Z轴旋转 // // transform_1 (0,1) = -sin(theta); // // transform_1 (1,0) = sin (theta); // // transform_1 (1,1) = cos (theta); // // transform_1 (0,2) = 0.3; //这样会产生缩放效果 // // transform_1 (1,2) = 0.6; // // transform_1 (2,2) = 1; // transform_1 (0,3) = 25; //这里沿X轴平移 // transform_1 (1,3) = 30; // transform_1 (2,3) = 380; Eigen::Affine3f transform_2 = Eigen::Affine3f::Identity(); // 在 X 轴上定义一个 2.5 米的平移. transform_2.translation() &lt;&lt; -5, 0.0, 0.0; float theta = M_PI/2; // 和前面一样的旋转; Z 轴上旋转 theta 弧度 transform_2.rotate (Eigen::AngleAxisf (theta, Eigen::Vector3f::UnitZ())); // 执行变换，并将结果保存在新创建的 transformed_cloud 中 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr transformed_cloud (new pcl::PointCloud&lt;pcl::PointXYZ&gt; ()); // 可以使用 transform_1 或 transform_2; t它们是一样的 pcl::transformPointCloud (*basic_cloud_ptr, *transformed_cloud, transform_2);通过数据时间获取相机参数//void Widget::mouseEventOccurred(const pcl::visualization::MouseEvent&amp; event, void *args) //{ // if (event.getButton () == pcl::visualization::MouseEvent::LeftButton &amp;&amp; event.getType () == pcl::visualization::MouseEvent::MouseButtonRelease) // { // Eigen::Affine3f viewer_pose = viewer-&gt;getViewerPose(); // Eigen::Vector3f pos_vector = viewer_pose * Eigen::Vector3f(0, 0, 0); // Eigen::Vector3f look_at_vector = viewer_pose.rotation() * Eigen::Vector3f(0, 0, 1) + pos_vector; // Eigen::Vector3f up_vector = viewer_pose.rotation() * Eigen::Vector3f(0, -1, 0); // m_SLAMCarPos.x = pos_vector[0]; // m_SLAMCarPos.y = pos_vector[1]; // m_SLAMCarPos.z = pos_vector[2]; // m_SLAMCarPos.roll = up_vector[0]; // m_SLAMCarPos.pitch = up_vector[1]; // m_SLAMCarPos.yaw = up_vector[2]; // setCamPosition(m_SLAMCarPos); // } //}读取 stl 文件并描绘//常用到的头文件 #include &lt;vtkRenderer.h&gt; #include &lt;vtkImageViewer2.h&gt; #include &lt;QVTKWidget.h&gt; #include &lt;vtkJPEGReader.h&gt; #include &lt;vtkTexture.h&gt; #include &lt;vtkTextureMapToCylinder.h&gt; #include &lt;vtkTransformTextureCoords.h&gt; #include &lt;vtkImageActor.h&gt; #include &lt;vtk3DSImporter.h&gt; #include &lt;vtkActor.h&gt; #include &lt;vtkActorCollection.h&gt; #include &lt;vtkCamera.h&gt; #include &lt;vtkNamedColors.h&gt; #include &lt;vtkProperty.h&gt; #include &lt;vtkSmartPointer.h&gt; #include &lt;vtkPolyData.h&gt; #include &lt;vtkSTLReader.h&gt; #include &lt;vtkAxesActor.h&gt; //zuobiaoxi #include &lt;vtkLight.h&gt; #include &lt;vtkTransform.h&gt; //zhuanhuang pingyi std::string inputFilename = &quot;~/luhu.stl&quot;; vtkSmartPointer&lt;vtkSTLReader&gt; reader = vtkSmartPointer&lt;vtkSTLReader&gt;::New(); reader-&gt;SetFileName(inputFilename.c_str()); reader-&gt;Update(); vtkSmartPointer&lt;vtkNamedColors&gt; colors = vtkSmartPointer&lt;vtkNamedColors&gt;::New(); colors-&gt;SetColor(&quot;Bkg&quot;, 0.3, 0.4, 0.5); vtkSmartPointer&lt;vtkJPEGReader&gt;bmpReader = vtkSmartPointer&lt;vtkJPEGReader&gt;::New(); bmpReader-&gt;SetFileName(&quot;/mnt/hgfs/linux_share/training_background.jpg&quot;);//读入纹理图 vtkSmartPointer&lt;vtkTexture&gt;texture = vtkSmartPointer&lt;vtkTexture&gt;::New(); //纹理映射 texture-&gt;SetInputConnection(bmpReader-&gt;GetOutputPort()); texture-&gt;InterpolateOn(); vtkSmartPointer&lt;vtkTextureMapToCylinder&gt; textureMap = vtkSmartPointer&lt;vtkTextureMapToCylinder&gt;::New(); textureMap-&gt;SetInputConnection(reader-&gt;GetOutputPort()); vtkSmartPointer&lt;vtkTransformTextureCoords&gt; transformTextureCoords = vtkSmartPointer&lt;vtkTransformTextureCoords&gt;::New(); transformTextureCoords-&gt;SetInputConnection(textureMap-&gt;GetOutputPort()); //transformTextureCoords-&gt;SetScale(1, 1, 0); // Visualize vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New(); mapper-&gt;SetInputConnection(/*textureMap*/transformTextureCoords-&gt;GetOutputPort()); vtkSmartPointer&lt;vtkActor&gt; actor = vtkSmartPointer&lt;vtkActor&gt;::New(); actor-&gt;SetMapper(mapper); actor-&gt;SetTexture(texture);//纹理为actor的一种属性 actor-&gt;GetProperty()-&gt;SetDiffuseColor(0.4, 0, 0); actor-&gt;GetProperty()-&gt;SetDiffuse(0.6); //漫反射 actor-&gt;GetProperty()-&gt;SetSpecular(0.4); actor-&gt;GetProperty()-&gt;SetSpecularColor( colors-&gt;GetColor3d(&quot;White&quot;).GetData()); actor-&gt;GetProperty()-&gt;SetSpecularPower(30.0); actor-&gt;GetProperty()-&gt;SetOpacity(1); //actor-&gt;SetPosition(100, 0, 0); vtkSmartPointer&lt;vtkLight&gt; myLight = vtkSmartPointer&lt;vtkLight&gt;::New(); //设置光照 myLight-&gt;SetColor(0,1,0); myLight-&gt;SetPosition(0,0,6); myLight-&gt;SetFocalPoint(renderer-&gt;GetActiveCamera()-&gt;GetFocalPoint()); renderer-&gt;AddLight(myLight); renderer-&gt;AddActor(actor); //renderer-&gt;AddActor(actor2); renderer-&gt;ResetCamera(); //renderer-&gt;GetActiveCamera()-&gt;Dolly(0.1); //显示缩放比例 renderer-&gt;ResetCameraClippingRange(); renderer-&gt;SetBackground(.3, .6, .3); // Background color greenvtk 编译出错 需考虑#include &lt;vtkAutoInit.h&gt; VTK_MODULE_INIT(vtkRenderingOpenGL); //这个必须要加，不然会报错 VTK_MODULE_INIT(vtkInteractionStyle);]]></content>
      <categories>
        <category>PCL</category>
      </categories>
      <tags>
        <tag>pcl,vtk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qvtk 环境搭建]]></title>
    <url>%2F2019%2F08%2F11%2Fqvkt-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境ubuntu 16.04 安装1、首先安装 cmake、qt5和qtcreator sudo apt-get install cmake qt5-default qtcreator2、安装 pcl 库 sudo apt-get install libpcl-dev3、下载vtk 源码 在VTK官网下载，https://www.vtk.org/download/ 4、编译源码 cd vtk-v6.2.0 mkdir build cd build cmake -DVTK_QT_VERSION:STRING=5 \ -DQT_QMAKE_EXECUTABLE:PATH=/usr/lib/x86_64-linux-gnu/qt5/bin/qmake \ -DVTK_Group_Qt:BOOL=ON \ -DCMAKE_PREFIX_PATH:PATH=/usr/lib/x86_64-linux-gnu/qt5/mkspecs/features/data/cmake \ -DBUILD_SHARED_LIBS:BOOL=ON \ /home/vtk-v6.2.0 make -j2编译可能报错这时我们想要的库已经存在了。 5、 复制库到 qt目录下，这样qt中就能看到qvtkWidget控件了 sudo cp ~/Desktop/vtk-v6.2.0/build/lib/libQVTKWidgetPlugin.so /usr/lib/x86_64-linux-gnu/qt5/plugins/designer错误The system is running in low-graphics mode解决方法：https://www.cnblogs.com/Undo-self-blog/p/8098104.html]]></content>
      <categories>
        <category>PCL</category>
      </categories>
      <tags>
        <tag>pcl,vtk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DLT（Diagnostic Log and Trace）简单应用]]></title>
    <url>%2F2019%2F07%2F26%2Fdlt-log%2F</url>
    <content type="text"><![CDATA[一、获取dlt-daemon源码 git clone https://github.com/GENIVI/dlt-daemon.git cd dlt-daemon mkdir build cd build cmake .. make sudo make install sudo ldconfigdlt-daemon 编译安装就完成了libdlt.so 位于 /usr/local/libdlt等头文件位置 /usr/local/include/dlt 二、启动dlt-daemon（守护进程）首先复制dlt.conf文件 cd dlt-daemon/src/daemon/ sudo cp dlt.conf /etc/ 可以通过sudo gedit /etc/dlt.conf 更改配置 DLT守护进程是从不同的应用程序中收集日志和跟踪信息的中心位置，这些日志和跟踪信息可以临时存储或永久存储，并传输到DLT客户机应用程序 三、输出日志程序编写可以参考 example 中例子 四、接收日志程序 通过安装 dlt-daemon会自动编译安装这个程序，也可以自己找到同名文件进行编译定制。 dlt-receive -f filter.txt -o ./log.dlt -a localhost dlt-receive -o ./log.dlt -a localhost 五、dlt-viewer 查看日志文件工具现装依赖包 sudo apt-get install libqt5serialport5-dev libqt5serialport5 git clone https://github.com/GENIVI/dlt-viewer.git mkdir build cd build cmake .. make 注意app context默认四字节 id默认一字节更加autosar 协议 所以最大255 输出日志程序， 和守护进程都有缓存机制。 The library path and include path must be set in the build environment prior to building a program using the shared dlt library. you may not call DLT_REGISTER_APP before fork() If your application uses fork(), you may not call DLT_REGISTER_APP before fork(). And fork() should never be called after DLT_REGISTER_APP. This is because of state information and inter process communication channel to daemon would be copied to new process, but threads would be not. # include &lt; dlt / dlt.h &gt; 首先要做的是包含DLT的标准头文件 DLT_DECLARE_CONTEXT (mycontext); 接下来是为应用程序的每个使用上下文创建实例。在使用任何上下文之前，这必须在源代码之外完成。 DLT_IMPORT_CONTEXT (mycontext); 如果在另一个软件模块中第二次使用上下文，则必须调用以下宏来访问上下文。 DLT_REGISTER_APP(“LOG”、“Test Application for Logging”); 在应用程序初始化的下一步中，应用程序必须在DLT守护进程中注册。应用程序的标识符(这里是“LOG”)最多有四个字符。 DLT_REGISTER_CONTEXT(mycontext，&quot;TEST&quot;，&quot; TEST Context for Logging&quot;); 然后必须在DLT守护进程中注册每个上下文。必须调用这个宏，以便DLT守护进程和客户机能够设置应用程序中上下文的日志级别。上下文的标识符(这里是“TEST”)最多有四个字符。此上下文使用默认日志级别和默认跟踪状态。 DLT_REGISTER_CONTEXT(mycontext，&quot;TEST&quot;，&quot; TEST Context for Logging&quot;，DLT_LOG_VERBOSE,DLT_TRACE_STATUS_ON); 作为替代，可以在期间提供特定的日志级别和跟踪状态 上下文的注册。现在在详细模式和非详细模式之间选择: DLT_LOG(mycontext ,DLT_LOG_WARN, DLT_INT(num),DLT_STRING(text)); 对于详细模式(默认):注册之后，可以使用上下文向DLT守护进程发送日志消息。必须使用日志消息的使用日志级别和参数的变量列表调用DLT_LOG宏。您将在附录API规范中找到完整的参数列表。 DLT_LOG_INT (mycontext DLT_LOG_WARN, num);DLT_LOG_STRING_INT(mycontext,DLT_LOG_WARN, text, num); 作为一种替代方法，可以使用高级日志宏来实现参数的特殊组合。您将在附录API规范中找到完整的列表。 DLT_LOG_ID(mycontext,DLT_LOG_WARN,msgid,DLT_INT(num),DLT_STRING(text)); 对于非详细模式:注册之后，可以使用上下文向DLT守护进程发送日志消息。必须使用日志消息的使用日志级别、消息id和参数变量列表调用DLT_LOG_ID宏。您将在API规范中找到完整的参数列表。 int injection_callback(uint32_t service_id, void \*data, uint32_t length); 高级日志宏在非详细模式下不可用。要使用的一个可选特性是消息注入特性。DLT客户机可以将用户定义的消息发送到应用程序，应用程序由服务id(例如0xfff)标识。如果应用程序接收到这样的消息，则调用回调。回调的格式为: DLT_REGISTER_INJECTION_CALLBACK (mycontext,0 xfff injection_callback); 若要在应用程式内登记回调，必须进行以下调用: DLT_TRACE_NETWORK(mycontext, DLT_NW_TRACE_CAN, headerlen, header, payloadlen, payload); 此外，还可以跟踪网络消息。这里必须指定接口DLT_NW_TRACE_CAN、头数据的长度和指向头数据的指针、负载数据的长度和指向负载数据的指针。如果没有头或有效负载可用，则必须将对应的长度设置为0，并且必须将对应的指针设置为NULL。 DLT_UNREGISTER_CONTEXT (mycontext);DLT_UNREGISTER_APP (); 在使用应用程序和上下文之后，必须从DLT守护进程注销它们。首先是所有上下文，然后必须注销应用程序。 参考genivi的DLT移植 DLT（Diagnostic Log and Trace）嵌入式系统程序运行记录]]></content>
      <categories>
        <category>汽车电子</category>
      </categories>
      <tags>
        <tag>autosar</tag>
        <tag>dlt</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse C基本操作]]></title>
    <url>%2F2019%2F07%2F26%2Feclipse%2F</url>
    <content type="text"><![CDATA[eclipse 安装ubuntu自带安装工具安装eclipse也是可行的，执行命令 #apt-get install eclipse。但是这样安装完后，并不会支持C/C++开发，还需要安装cdt插件，执行命令#apt-get install eclipse-cdt。 eclipse 导入 现有工程Project Explorer 右键-&gt;import-&gt; General -&gt; Existing Project into Workspace eclipse 配置工程编译设置propertise-&gt;c/c++ build-&gt;settings-&gt;Tool SettingsLibraries 设置依赖库Includes 设置依赖头文件GCC C Compiler-&gt;Command: gcc 后面可以加 参数-&gt;Build Artifactartifact name 生成文件名 运行设置输入运行参数位置在 debug configure-&gt;arguments 生成动态库C++ Project-&gt;Shared Library Linux下Eclipse编译时，报recompile with -fPIC错误，解决方法错误：relocation R_X86_64_32 against `‘。rodata’ can not be used when making a shared object; recompile with -fPIC解决方法是：右键Eclipse工程，propertise-&gt;c/c++ build-&gt;settings-&gt;GCC C Compiler-&gt;Command: gcc 后面加上-fPIC,重新编译]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyqt5笔记]]></title>
    <url>%2F2019%2F07%2F21%2Fpyqt%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[QChart 图表描绘self._plotChart = QChart() self._plotChart.legend().hide() #隐藏图例 self._plotChart.setMargins(QMargins(3, 0, 0, 5)) # 设置内边框间距左上右下 self._plotChart.setBackgroundRoundness(0) # 设置成直角 self._plotChart.createDefaultAxes() self._plotChart.axisX().setLabelFormat(chartProperty[GlobalVar.AXIS_X_PRO]._labelFormat) # 设置坐标轴格式 self._plotChart.axisX().setRange(chartProperty[GlobalVar.AXIS_X_PRO]._min, chartProperty[GlobalVar.AXIS_X_PRO]._max) # 设置坐标轴范围 self._plotChart.axisX().setTickCount(10) # 设置多少格 实线 self._plotChart.axisX().setMinorTickCount(4) # 设置多少分隔 虚线 self._plotChart.axisX().setGridLineVisible(False) #设置的实线是否可见listWidget 列表自定义class MyLable(QWidget, Ui_Form): &quot;&quot;&quot;定义列表的一个item，可以根据需求自定义 &quot;&quot;&quot; def __init__(self, paramDict): &quot;&quot;&quot; :param paramDict &quot;&quot;&quot; super(MyLable, self).__init__() self.setupUi(self) self.name.setText(str(paramDict[&apos;name&apos;])) self.sex.setText(paramDict[&apos;sex&apos;]) self.age.setText(str(paramDict[&apos;age&apos;])) self.date.setText(str(paramDict[&apos;date&apos;])) class TestView(QMainWindow, Ui_MainWindow): def __init__(self): super(TestView, self).__init__() self.setupUi(self) paramdict ={&apos;name&apos;: &apos;zhang&apos;, &apos;sex&apos;: &apos;U&apos;, &apos;age&apos;: &apos;13&apos;, &apos;date&apos;: &apos;2018-11-1&apos;} # 创建列表 for i in range(3): paramdict[&apos;age&apos;] = i self._setItem(paramdict ,i ) # 设置默认选择第一个 self.listWidget.setCurrentRow(0) # 定义item 点击槽 self.listWidget.itemClicked.connect(self.itemClickSlot) # 设置 item 项 def _setItem(self, paramDict, i): item_widget = QListWidgetItem() item_widget.setSizeHint(QSize(0, 83)) self.listWidget.addItem(item_widget) label = MyLable(paramDict) self.listWidget.setItemWidget(item_widget, label) # 设置 item上 按键关联事件 label.pushButton.clicked.connect(lambda :self.deleteItem(i)) def itemClickSlot(self): print(self.listWidget.currentIndex().row()) def deleteItem(self, i): print(&apos;点击按钮{0}&apos;.format(i)) self.listWidget.takeItem(i) # 删除当前item # 全部刪除item # for i in range(self.listWidget.count()): # print(i) # self.listWidget.takeItem(0)注意：setStyleSheet:QListWidget::item:selected 设置选中后背景图片QListWidget::item:selected{background-image: url(:/img/resources/list_background.png);} PyQt中“明天”的表示法比如说我们有一个DateEdit控件，叫做beginDayDateEdit,要给它赋上“今天”这个值就可以这样写 beginDayDateEdit.setDate(QtCore.QDate.currentDate())将currentDate先用toJulianDay转成数值形式，然后加1，再用fromJulianDay转回来就可以设置成明天或者其他想要表示得日期 tomorrow = QtCore.QDate.currentDate().toJulianDay() + 1 beginDayDateEdit.setDate(QtCore.QDate.fromJulianDay(tomorrow))不过在处理DateTimeEdit的控件会有所差异，此时用的是toTime_t和fromTime_t 注意:由于控件改变了，setDate也变成了setDateTime,toTime_t把当前时间转成了从1970年1月1日00:00:00到现在的总秒数，要加1天的话，加上86400秒就行了。 tomorrow = QtCore.QDateTime.currentDateTime().toTime_t() + 86400 self.beginDayDateEdit.setDateTime(QtCore.QDateTime.fromTime_t(tomorrow))设置日历显示的默认时间是当前时间的前7天self.starttime.setDate(QDate.currentDate().addDays(-7)设置搜索框，搜索提示setPlaceholderText(&apos;nameortelephone&apos;)信号槽连接使用Pyqt编程过程中，经常会遇到给槽函数传递额外参数的情况。但是信号-槽机制只是指定信号如何连接到槽，信号定义的参数被传递给槽，而额外的参数（用户定义）不能直接传递。而传递额外参数又是很有用处。你可能使用一个槽处理多个组件的信号，有时要传递额外的信息。一种方法是使用lambda表达式。button1.clicked.connect(lambda: self.on_button(1))解释一下，on_button是怎样处理从两个按钮传来的信号。我们使用lambda传递按钮数字给槽，也可以传递任何其他东西—甚至是按钮组件本身（假如，槽打算把传递信号的按钮修改为不可用）第2个方法是使用functools里的partial函数。button1.clicked.connect(partial(self.on_button, 1)) 按键事件当我们关闭一个窗口时，在PyQt中就会触发一个QCloseEvent的事件，正常情况下会直接关闭这个窗口， #但是我们不希望这样的事情发生，所以我们需要重新定义QCloseEvent，函数名称为closeEvent不可变 pycharm 安装包可以更改源pycharm 可以根据自己使用习惯更改自己常用软件的快捷键]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pyqt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式linux系统与主机通过网络传输文件]]></title>
    <url>%2F2019%2F07%2F13%2Flinux%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[1、从服务器上下载文件scp username@servername:/path/filename /var/www/local_dir（本地目录） 例如scp root@192.168.0.101:/var/www/test.txt 把192.168.0.101上的/var/www/test.txt 的文件下载到/var/www/local_dir（本地目录） 2、上传本地文件到服务器scp 文件名字 服务器用户名字@服务器ip:目录scp /path/filename username@servername:/path例如：scp /var/www/test.php root@192.168.0.101:/var/www/ 把本机/var/www/目录下的test.php文件上传到192.168.0.101这台服务器上的/var/www/目录中例子：scp index.html root@58.87.124.110:/home/service-tomcat/webapps/ 3、从服务器下载整个目录scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录）例如:scp -r root@192.168.0.101:/var/www/test /var/www/ 4、上传目录到服务器同文件上传只是在文件名字前面加上-rscp -r local_dir username@servername:remote_dir例如：scp -r test/ root@192.168.0.101:/var/www/ 把当前目录下的test目录上传到服务器的/var/www/ 目录 注意：1、要在要上传文件的前面加-r，否则报错 static: not a regular file -r: No such file or directory2、要上传文件后面最好加/3、可以简单理解成网络中的 cp 命令]]></content>
      <categories>
        <category>嵌入式linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[嵌入式linux系统与主机通过串口传输文件]]></title>
    <url>%2F2019%2F07%2F13%2Flinux%E4%B8%B2%E5%8F%A3%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[串口指令操作1、查看串口是否可用 可以对串口发送数据比如对com1口，echo /dev/ttyS02、查看串口名称使用 ls -l /dev/ttyS* 一般情况下串口的名称全部在dev下面，如果你没有外插串口卡的话默认是dev下的ttyS,一般ttyS0对应com1，ttyS1对应com2，当然也不一定是必然的；3、查看串口驱动 cat/proc/tty/drivers/serial4、查看串口设备 dmesg | grep ttyS5、查一下板子上的串口有没有设备 dmesg | grep ttyS* 如果有ttyS设备，再看/dev/有没有ttyS*，如没有就建立一个：mknod /dev/ttyS0 c 4 64 如果板子的设备中没有标准串口设备ttyS0，也没有ttySAC0。/dev下应该有一个USB串口：/dev/ttyUSB0. 当一个串行卡或数据卡被侦测到时，它会被指定成为第一个可用的串行设备。通常是/dev/ttyS1(cua1)或/dev/ttyS2(cua2)，这完成看原已内建的串口数目。ttyS*设备会被报告在/var/run/stab内。 PC上的串口一般是ttyS，板子上Linux的串口一般叫做ttySAC补充:如果需要查看这个串口设备输出cat ttyUSB0 如果需要对这个设备输入echo aaaaa&gt;ttyUSB0 嵌入式linux系统与主机通过串口传输文件我想如果要从PC机下载东西到开发板的嵌入式linux系统里面，很多人首先会想到用tftp sftp等网络工具从网口下载。但如果网络用不了，只能通过串口下载怎么办呢？这个时候有两个工具能帮到你：一个是zmrx、zmtx，另外一个是lsz、lrz。个人觉得zmrx/zmtx没有lsz/lrz稳定，建议还是用后者。下面介绍一下lsz/lrz的使用方法。 一、编译lrzsz并下载到开发板上从http://download.chinaunix.net/download/0007000/6293.shtml下一个lrzsz的tar包，解压缩后输入./configure，然后进入了src文件夹中，修改了src文件夹中的Makefile文件，配置为与手机对应的交叉编译器，运行make，ok！得到两个可执行文件sz，rz（或者 lsz，lrz），把它们下载到开发板linux系统的/bin目录下。 二、情况1: PC机用windows操作系统如果PC机用的是windows操作系统，串口通信工具可以用系统自带的超级终端。下面介绍一下传输文件的方法。 1、开发板–&gt;PC机在开发板上输入 sz filename。在PC机上点击超级终端的菜单“传送”-&gt; “接收文件”，选择下载的位置和Zmodem 与崩溃恢复协议，点击接收即可。 2、PC机–&gt;开发板在开发板上先进入/tmp 目录，然后输入 rz。在PC机上点击超级终端的菜单“传送”-&gt; “发送文件”，选择目标文件和Zmodem 与崩溃恢复协议，点击发送即可。]]></content>
      <categories>
        <category>嵌入式linux</category>
      </categories>
      <tags>
        <tag>串口</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canopen 入门]]></title>
    <url>%2F2019%2F06%2F22%2FCanFestival%2F</url>
    <content type="text"><![CDATA[相对于其他常用的国外开源的CANopen协议栈，CanFestival具有许多明显的优势： CanFestival为开发者提供了许多工具，以提高开发的便利性。例如用于生成节点对象字典源代码的对象字典编辑器，以及便于开发者自由配置编译选项的配置脚本。 CanFestival能够运行于多种类型的平台。CanFestival源代码由ANSI-C编写，驱动和例程的编译情况仅取决于具体的编译工具。在目前最新的版本中，官方提供了对于多种硬件平台的驱动。此外，CanFestival可以在任意类Unix系统下编译和运行，如Linux和FreeBSD。 CanFestival协议功能完整，完全符合CANopen标准。CanFestival完全支持2002年2月发布的CIA DS-301 V4.02标准，并支持CiA DS302中的简明DFC协议 CanFestival 3.0 RC3 源代码的目录结构如下表所示： 文件路径 文件说明 备注 ./src 与处理器无关的的 CANopen 协议栈 ANSI-C 源代码 ./include 针对各处理器的头文件 ./driver 针对各硬件的驱动 ./examples 用于测试的程序 ./objdictgen 带有图形用户界面的对象字典编辑器 ./doc 说明文档 在CanFestival中，所有源代码可以分为四大部分，分别是目标接口、CAN接口、CanFestival库文件以及主/从节点的应用。其中，CanFestival库文件是整个协议的核心，包括调度管理，节点管理（对象字典访问objacces.c、状态机state.c），CANopen协议（服务数据对象sdo.c、过程数据对象pdo.c、同步对象sync.c、自动波特率对象lss.c、网络管理对象nmtMaster.c和nmtSlave.c）。这些文件在移植时是不需要修改的。主/从节点的应用包括节点状态反馈和设备对象字典的定义。目标接口包括节点硬件的驱动以及对于操作系统的接口，这也是进行移植时主要修改的对象。 由于周期性发射同步信号、心跳报文或SDO超时信号需要设定一系列定时信号来提醒系统进行这些工作，所以CANopen节点必须能实现定时功能。CanFestival在timer.c中执行了一个微型调度程序，他可以使用一个定时器来模拟许多定时器。该调度程序会建立并管理一个警报表，并且在规定的时间发出信号。 本次测试中使用的CanFestival用户手册是PDF文档《CanFestival manual_en》。这篇文档详细介绍了CanFestival 工程中各类接口函数、库函数和一些示例应用程序，其中包括利用Canopen协议开发的示例程序。文档还介绍CanFestival的主要特点和理解这个开源工程代码的过程中需要使用的一些工具和分析方法。这是在进行Canopen通信协议开发过程中需要仔细研读的说明文档 CanFestival工程中文件分类及各部分的功能如下图所示： 基于 rt-thread 中 CanFestival 使用入门 使用 rt-thread 中 CanFestival 前期准备：定时器驱动、CAN硬件驱动 配置包， 位于RT-Thread online packages → miscellaneous packages → CanFestival: A free software CANopen framework 编译下载就会可以收发canopen数据了。需要在canopen_recv_thread_entry线程增加延时为了调度 上位机可以通过 CANPRO 解析接收数据和发送数据]]></content>
      <categories>
        <category>CAN</category>
      </categories>
      <tags>
        <tag>can</tag>
        <tag>canopen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S32K AUTOSAR 环境搭建]]></title>
    <url>%2F2019%2F06%2F20%2FS32K_AUTOSAR%2F</url>
    <content type="text"><![CDATA[autosar MCAL 下载 安装根据需求在nxp 官网搜索需要的版本下载 和 EB 下载在一个目录下.注意：下载后保存lience autosar OS 下载 安装autosar os 目前只有4.0支持 s32k系列芯片，查找时选择4.0一步一步向下点就能找到下载地址。注意：下载后保存lience EB 简介EB tresos Studio是一个基于Eclipse符合AU-TOSAR标准的车用软件模块配置和代码生成工具环境。通过它，用户可以配置软件模块，验证配置的一致性，以及为标准软件模块(如AUTOSAR标准软件内核)生成代码。 EB tresos下载注意：根据MCAL releasenote中说明下载对应版本。 NXP官网下载链接查找，这个链接找到有点难度，我的方法： 搜索autosar 选择AUTOSAR-4-2: AUTOSAR 4.2.x (Classic Platform) Software 点击下载 选择需要的版本点击下载 进入需要的目录 EB tresos 安装注意：下载时记录lience 安装问题No pagkages were found that can be installed! 解压 下载的 .gz文件 并重命名为 .uip格式。 S32DS 下载注意： 如链接有问题查找 S32DS即可 安装教程：https://blog.csdn.net/zz56z56/article/details/88907425 参考NXP_AUTOSAR_MCAL开发环境搭建引导_S32K14x系列 AUTOSAR各版本对比及模块统计 NXP软件版本介绍]]></content>
      <categories>
        <category>汽车电子</category>
      </categories>
      <tags>
        <tag>S32K</tag>
        <tag>AUTOSAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo github搭建 主题配置]]></title>
    <url>%2F2019%2F06%2F17%2Fhexo%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[HEXO 常用命令hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 两个命令的作用是相同的hexo generate –deployhexo deploy –generate 参考GitHub+Hexo 搭建个人网站详细教程Hexo 搭建个人博客系列：基础建站篇]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
